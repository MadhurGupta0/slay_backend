================================================================================
PASSKEY DISCOVERABLE CREDENTIALS - BACKEND CHANGES
================================================================================
Date: 2026-01-30
Feature: Enable Google Password Manager passkey selector (Snapchat-like UX)

================================================================================
PROBLEM STATEMENT
================================================================================
Previously, passkey login required email BEFORE authentication. Users had to:
1. Enter email
2. Click "Sign in with Passkey"
3. Authenticate with fingerprint

This prevented Google Password Manager from showing the passkey account selector
(like Snapchat does), because we were sending `allowCredentials` with specific
credential IDs.

NEW FLOW (Snapchat-like):
1. User clicks "Sign in with Passkey" (no email needed)
2. Google Password Manager shows ALL passkeys for this app
3. User selects account, scans fingerprint
4. Backend looks up user by credential_id
5. User is logged in

================================================================================
NEW LIBRARY IMPORTS
================================================================================

BEFORE:
    from webauthn.helpers import parse_registration_credential_json

AFTER:
    from webauthn.helpers import parse_registration_credential_json, parse_authentication_credential_json
                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                                     NEW: For parsing authentication credentials

================================================================================
NEW HELPER FUNCTIONS ADDED (Lines ~1078-1165)
================================================================================

1. GLOBAL CHALLENGE STORAGE (in-memory, thread-safe)
   ----------------------------------------------------
   _global_challenge_lock = threading.Lock()
   _global_challenge_data = {"challenge": None, "expiry": None}

   def store_global_webauthn_challenge(challenge_str: str, expiry_minutes: int = 5):
       """Store challenge globally for discoverable credentials (no email needed)"""
       # Stores challenge in memory with expiry timestamp
       # Thread-safe using lock

   def get_global_webauthn_challenge() -> Optional[str]:
       """Retrieve the global WebAuthn challenge"""
       # Returns challenge if not expired, None otherwise

   def clear_global_webauthn_challenge():
       """Clear the global WebAuthn challenge after use"""


2. CREDENTIAL LOOKUP BY ID
   ------------------------
   def get_credential_by_id(credential_id: str) -> Optional[dict]:
       """Find a passkey credential by its ID across ALL users"""
       # Queries all users with passkey_credentials
       # Searches each user's passkey_credentials JSON array
       # Returns: {credential_id, public_key, sign_count, device_name, user_id, user_email}


3. USER LOOKUP BY ID
   ------------------
   def get_user_by_id(user_id: str) -> Optional[dict]:
       """Get user by their database ID"""
       # Simple lookup by primary key

================================================================================
PASSKEY_LOGIN_BEGIN - CHANGES
================================================================================

ORIGINAL CODE (required email):
-------------------------------
@app.route('/api/passkey/login/begin', methods=['POST'])
def passkey_login_begin():
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    email = data.get('email')

    if not email:
        return jsonify({"success": False, "error": "Email is required"}), 400

    # ... validate email, get user, get credentials ...

    # Build allowCredentials list (PREVENTS passkey selector!)
    allowed_credentials = []
    for cred in credentials:
        credential_id_bytes = base64.urlsafe_b64decode(cred["credential_id"] + '==')
        allowed_credentials.append(
            PublicKeyCredentialDescriptor(id=credential_id_bytes, type="public-key")
        )

    authentication_options = generate_authentication_options(
        rp_id=RP_ID,
        challenge=challenge_bytes,
        allow_credentials=allowed_credentials,  # <-- THIS BLOCKS PASSKEY SELECTOR
        user_verification=UserVerificationRequirement.PREFERRED,
    )

    # Store challenge per-user
    store_webauthn_challenge(email, challenge_str, expiry_minutes=5)


NEW CODE (no email required, enables passkey selector):
-------------------------------------------------------
@app.route('/api/passkey/login/begin', methods=['POST'])
def passkey_login_begin():
    try:
        # Generate challenge
        challenge_str = generate_challenge()
        challenge_bytes = base64.urlsafe_b64decode(challenge_str + '==')

        authentication_options = generate_authentication_options(
            rp_id=RP_ID,
            challenge=challenge_bytes,
            user_verification=UserVerificationRequirement.REQUIRED,
            # NO allowCredentials = Google Password Manager shows ALL passkeys!
        )

        # Store challenge GLOBALLY (not per-email)
        store_global_webauthn_challenge(challenge_str, expiry_minutes=5)

        # Serialize with multiple fallbacks for Pydantic v1/v2 compatibility
        try:
            options_dict = json.loads(authentication_options.model_dump_json())
        except (AttributeError, TypeError, ValueError):
            try:
                options_dict = authentication_options.model_dump(mode='json')
            except (AttributeError, TypeError, ValueError):
                try:
                    options_dict = authentication_options.dict()
                except (AttributeError, TypeError, ValueError):
                    options_dict = vars(authentication_options)

        options_dict = remove_ellipsis(options_dict)

        return jsonify({
            "success": True,
            "options": options_dict
        }), 200

    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"Failed to begin passkey login: {str(e)}"
        }), 500


KEY DIFFERENCES:
- No email required in request
- No allowCredentials sent (enables OS passkey selector)
- Challenge stored globally, not per-user
- Added Pydantic v1/v2 serialization compatibility

================================================================================
PASSKEY_LOGIN_COMPLETE - CHANGES
================================================================================

ORIGINAL CODE (required email):
-------------------------------
@app.route('/api/passkey/login/complete', methods=['POST'])
def passkey_login_complete():
    data = request.get_json()

    email = data.get('email')
    credential = data.get('credential')

    if not email:
        return jsonify({"success": False, "error": "Email is required"}), 400

    # Get user by email
    user = get_user_by_email(email)

    # Find credential in user's passkey_credentials
    credentials = get_passkey_credentials(email)
    matching_cred = None
    for cred in credentials:
        if cred.get("credential_id") == credential_id:
            matching_cred = cred
            break

    # Get challenge from user's verification_code
    stored_challenge = user.get("verification_code")

    # Verify
    verification = verify_authentication_response(
        credential=AuthenticationCredential.parse_raw(json.dumps(cleaned_credential)),
        ...
    )


NEW CODE (no email required, credential-first lookup):
------------------------------------------------------
@app.route('/api/passkey/login/complete', methods=['POST'])
def passkey_login_complete():
    try:
        data = request.get_json()
        credential = data.get('credential')

        if not credential:
            return jsonify({"success": False, "error": "Credential is required"}), 400

        credential_id = credential.get('id')
        if not credential_id:
            return jsonify({"success": False, "error": "Invalid credential"}), 400

        # LOOKUP CREDENTIAL FIRST (not email!)
        # Searches ALL users' passkey_credentials to find matching credential_id
        stored_cred = get_credential_by_id(credential_id)
        if not stored_cred:
            return jsonify({"success": False, "error": "Credential not found"}), 404

        # Get user from credential lookup result
        user = get_user_by_id(stored_cred["user_id"])
        if not user:
            return jsonify({"success": False, "error": "User not found"}), 404

        # Get GLOBAL challenge (not per-user)
        stored_challenge = get_global_webauthn_challenge()
        if not stored_challenge:
            return jsonify({"success": False, "error": "Session expired"}), 400

        challenge_bytes = base64.urlsafe_b64decode(stored_challenge + '==')
        public_key_bytes = base64.b64decode(stored_cred["public_key"])
        sign_count = stored_cred.get("sign_count", 0)

        cleaned_credential = remove_ellipsis(credential)
        validated_origin = get_validated_origin(credential)

        # Parse credential using webauthn helper (not Pydantic methods)
        credential_json = json.dumps(cleaned_credential)
        parsed_credential = parse_authentication_credential_json(credential_json)

        verification = verify_authentication_response(
            credential=parsed_credential,
            expected_challenge=challenge_bytes,
            expected_origin=validated_origin,
            expected_rp_id=RP_ID,
            credential_public_key=public_key_bytes,
            credential_current_sign_count=sign_count,
        )

        # Update sign count using email from credential lookup
        update_sign_count(stored_cred["user_email"], stored_cred["credential_id"], verification.new_sign_count)
        clear_global_webauthn_challenge()

        return jsonify({
            "success": True,
            "message": "Passkey login successful",
            "user": {
                "id": user["id"],
                "email": user["email"],
                "username": user["username"]
            }
        }), 200

    except Exception as e:
        return jsonify({
            "success": False,
            "error": f"Passkey verification failed: {str(e)}"
        }), 400


KEY DIFFERENCES:
- No email required in request
- Credential lookup by credential_id FIRST (searches all users)
- User retrieved from credential lookup result
- Global challenge storage instead of per-user
- Uses parse_authentication_credential_json() instead of Pydantic parse_raw()

================================================================================
FRONTEND CHANGE (for reference)
================================================================================

The frontend also needed a change in LoginScreen.tsx:

BEFORE (wrong - converted to bytes):
    const publicKey = {
        challenge: base64urlToUint8Array(rawOptions.challenge),  // WRONG!
        ...
    };

AFTER (correct - keep as string):
    const publicKey = {
        challenge: rawOptions.challenge,  // Keep as base64url string!
        ...
    };

react-native-passkey expects challenge as base64url STRING, not Uint8Array.
Converting to bytes caused the challenge in clientDataJSON to be malformed.

================================================================================
DATABASE SCHEMA (unchanged)
================================================================================

The passkey_credentials column in slay_users table remains unchanged:
[
  {
    "credential_id": "ag-DMtYQpXyegUBeRTLIPA",
    "public_key": "pQECAyYgASFYI...",
    "sign_count": 0,
    "device_name": "android",
    "created_at": "2026-01-30T05:59:02.112173"
  }
]

The new get_credential_by_id() function searches this JSON array across all users.

================================================================================
SUMMARY OF CHANGES
================================================================================

1. NEW IMPORT: parse_authentication_credential_json from webauthn.helpers

2. NEW FUNCTIONS:
   - store_global_webauthn_challenge()
   - get_global_webauthn_challenge()
   - clear_global_webauthn_challenge()
   - get_credential_by_id()
   - get_user_by_id()

3. MODIFIED ENDPOINTS:
   - /api/passkey/login/begin - No email required, no allowCredentials
   - /api/passkey/login/complete - Credential-first lookup, global challenge

4. RESULT: Google Password Manager now shows passkey selector like Snapchat!

================================================================================
